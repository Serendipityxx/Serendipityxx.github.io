---
layout:  post
title:   "x86_64 汇编"
date:   2025-1-21 15:48:00
author:  'Xiangxiao'
header-img: 'img/post-bg-2015.jpg'
catalog:   true
tags:
- x86_64
- 汇编
- 汇编命令
---

# x86_64 汇编

# CPU 分类

目前主要就是两种架构，分别是 x86 架构和 arm 架构。

- x86 架构：

  - x86、x86_64，分别是 x86 架构的 32 位版本和 64 位版本，后者也兼容 32 位
  - amd64，跟 x86_64 一样
- arm 架构

  - arm64 架构
  - aarch64 架构

# x86_64 架构

## 寄存器

寄存器是计算机中央处理器（CPU）内部的一种高速存储部件，用于临时存放数据、指令和地址等信息，是 CPU 进行运算和控制的核心组件之一。

### 通用寄存器

x86_64 共有 16 个 64 位通用寄存器，每个寄存器可根据操作数长度（64 位、32 位、16 位、8 位）使用不同的名称（通过寄存器名后缀区分）。这些寄存器既可以用于数据运算，也可用于地址存储，部分寄存器还保留了特殊用途。

**通用寄存器的特殊用途说明：**

1. ABI 约定：在 Linux/UNIX 系统的函数调用中，寄存器的使用遵循 System V AMD64 ABI 标准：

   - 函数参数传递：`rdi`（第 1 个）、`rsi`（第 2 个）、`rdx`（第 3 个）、`rcx`（第 4 个）、`r8`（第 5 个）、`r9`（第 6 个），超出部分通过栈传递。
   - 返回值：`rax`（64 位）、`rdx:rax`（128 位，如乘法结果）。
   - 寄存器保存规则：`rbx`、`rbp`、`rsp`、`r12`-`r15` 由被调用者保存（需恢复原值），其余由调用者自行保存。
2. 字符串操作：`rsi`（源地址）、`rdi`（目标地址）、`rcx`（操作长度）配合 `movs`（移动）、`cmps`（比较）等指令实现高效字符串处理。
3. 栈操作：`rsp` 是栈顶指针，每次 `push`/`pop` 指令会自动修改其值；`rbp` 可选作为栈帧基地址，用于定位函数参数和局部变量。

### 标志位寄存器

标志位寄存器（64 位为 `rflags`）是一个特殊寄存器，用于存储运算结果的状态和 CPU 的控制信息，共包含 19 个标志位（部分为保留位）。每个标志位占 1 位（0 或 1），主要分为状态标志和控制标志两类。

1. 状态标志（Status Flags）

记录算术 / 逻辑运算的结果特征，用于条件跳转等指令判断：

1. 控制标志（Control Flags）

用于控制 CPU 的运行模式或行为，上述 `TF`、`IF`、`DF` 均属于控制标志，其值可通过指令（如 `sti`/`cli` 修改 `IF`，`cld`/`std` 修改 `DF`）主动修改。

### 指令指针寄存器

1. 指令指针寄存器（`rip`）
   - 64 位指令指针，存放下一条要执行的指令的地址，CPU 执行完当前指令后自动根据指令长度递增 `rip`。
   - 不可通过 `mov` 直接修改，需通过 `jmp`、`call`、`ret`、`jcc`（条件跳转）等指令间接更新，是程序流程控制的核心。

### 段寄存器

段寄存器是 x86 架构历史遗留的重要组件，最初用于解决 16 位 CPU 的内存寻址限制（通过 “段基址 + 偏移量” 扩展地址空间）。在 64 位模式下，段寄存器的功能被大幅简化，但仍保留用于内存保护和线程局部存储（TLS）。

x86_64 有 6 个 16 位段寄存器：`cs`、`ds`、`es`、`fs`、`gs`、`ss`，每个寄存器存储一个 “段选择子”（Segment Selector），用于索引全局描述符表（GDT）或局部描述符表（LDT），获取段的基地址、限长和权限信息。

**各段寄存器的作用：**

1. `cs`（Code Segment，代码段寄存器）

   - 指向当前执行代码所在的内存段，包含代码的基地址和执行权限（如特权级）。
   - 在 64 位模式下，`cs` 的特权级（CPL）决定 CPU 当前运行级别（0 为内核态，3 为用户态），是系统安全的核心控制之一。
   - 不可通过 `mov` 指令直接修改（需通过 `jmp`、`call`、`ret` 等控制转移指令间接更新）。
2. `ss`（Stack Segment，栈段寄存器）

   - 指向当前栈所在的内存段，与 `rsp` 配合定义栈的地址范围和权限。
   - 64 位模式下，栈段的基地址通常被忽略（视为 0），但段的权限检查仍有效（如防止用户态访问内核栈）。
3. `ds`（Data Segment，数据段寄存器）
   `es`（Extra Segment，附加数据段寄存器）

   - 传统上用于访问数据段内存，64 位模式下默认基地址为 0，主要用于兼容 16/32 位程序。
   - 现代系统中，`ds` 和 `es` 通常不主动修改，默认指向全局数据段。
4. `fs`、`gs`（额外段寄存器）

   - 功能灵活，无固定用途，由操作系统自定义：
     - 在 Linux 中，`fs` 用于用户态线程局部存储（TLS），通过 `fs:[0]` 可访问当前线程的局部变量；`gs` 用于内核态（如存放当前进程描述符 `task_struct` 指针）。
     - 在 Windows 中，`gs` 用于用户态 TLS 和异常处理（如 `gs:[0x30]` 指向线程信息块 TEB）。

## 常见汇编指令

x86_64 架构的汇编指令集非常丰富，涵盖数据传输、算术运算、逻辑操作、控制流、栈操作等多个类别。以下是最常用的汇编指令及其功能说明，以 AT&T 语法（Linux 环境常用）为例：

### 数据传输指令

用于在寄存器、内存和立即数之间传递数据。

### 算数与逻辑指令

用于数值计算和位操作。

- 算数运算
- 逻辑操作

### 控制流指令

用于改变程序执行顺序（分支、循环、函数调用）。

- 无条件跳转
- 条件跳转
- 函数调用和返回
- 循环控制

### 栈与帧的操作

用于函数调用时的栈帧管理。

### 字符串操作指令

配合 `rsi`（源）、`rdi`（目标）、`rcx`（计数）寄存器高效处理字符串

## 汇编相关的一些命令

Linux 下

gcc 相关

- 预处理操作：gcc -E main.c -o main.i
  - 展开#include，将头文件内容插入当前文件中
  - 处理#define，替换宏定义
  - 条件编译，处理#if/#else/#endif 等，根据条件保留删除代码块
  - 删除注释，将//或者/*注释删除
  - 添加行号和文件名表示，便于后面编译阶段报错定位

  ```c
  ```

直接 cat 或者 more 查看

```

- 编译操作：gcc -S main.i -masm=intel -o main.s
	- 词法分析，语法分析，语义分析
	- 代码优化：常量折叠，循环展开，根据优化级别决定
	- 生成汇编代码
	```c
直接more、cat、vi查看
```

- 汇编操作：gcc -c main.s -o main.o
  - 汇编指令翻译：翻译为对应的机器码。
  - 符号表构建：记录变量函数的地址。
  - 段划分，将代码、数据分别放入 text 段、data 段。
    （.o)文件是二进制文件，无法直接执行，缺少库依赖和入口地址。

  ```shell
  ```

objdump -d main.o #反汇编目标文件，查看机器码对应的汇编命令。
readelf -S main.o #查看目标文件的段信息。

```

- 链接操作：gcc main.o -o main
	- 符号解析：将目标文件中未定义的符号与库文件中实现关联。
	- 重定位：修改目标文件中的相对地址为绝对地址。
	- 合并段：将所有目标文件中的段合并为统一的段。
	- 条件ELF头：包含程序入口地址main，运行时信息等。
	```shell
objdump -d main    # 反汇编可执行文件，查看完整机器码
readelf -h main    # 查看ELF文件头（包含入口地址等信息）
```
